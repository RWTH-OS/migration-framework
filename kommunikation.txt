Umsetzung der Schnittstellen mit MQTT
=====================================


Annahmen
---------

* Basiert auf schnittstellen.txt von <datum>
* Scheduler kennt $ hostname aller knoten.


Aufbau einer MQTT Nachricht
---------------------------

Eine MQTT Nachricht besteht aus zwei Teilen

* Topic

* Payload in YAML


Ablauf der Kommunikation
------------------------

Grundsätzlich ist das ein einfaches Publisher-Subscriber Pattern.
Hier eine grobe Übersicht.

1. Ein Teilnehmer verbinden sich mit einem Server.

*  Ein Teilnehmer melden sich für N Topics an.

*  Der Server schickt alle Nachrichten für die sich ein Teilnehmer angemeldet
   hat.

2. Ein Teilnehmer meldet sich ab.


Topics
------

Eine Übersicht über die aktuell verwendeten Topics. Grunsätzlich ist der Aufbau
wie folgt: <Host>-<Komponente>.

* <host>-agent: Ein Topic um Nachrichten an den Agenten auf node <host> zu
                schicken.

* <host>-migfra: Ein Topic um Nachrichten an das Migrationsframework auf node <host>
                 zu schicken.

* <host>-s: Ein Topic um mit dem Scheduler zu kommunizieren der für node <host>
            zuständig ist.

* scheduler: Ein Topic das an alle Scheduler Instanzen geht.


Genaues Kommunikationsprotokoll für die verschiedenen Anwendungsfälle
---------------------------------------------------------------------

* INIT
  Knoten wird gestartet. Meldet und meldet sich beim Scheduler an.
  Source: Agent
  Topic: scheduler
  Payload:
=============
task: init
source: <hostname>
=============
  Erwartetes Verhalten: Der für den Knoten zuständige Scheduler empfängt die
                        Nachricht und nimmt den Knoten in sein Scheduling mit
                        auf.
  Implementierung: Agent wird automatisch bei Systemstart gestartet und
                   verschickt die o.g. Nachricht.


* INIT AGENT
  Der Scheduler meldet sich beim Agenten und liefert eine initiale Konfiguration
  Source: Scheduler
  Topic: <hostname>-A
  Payload:
=============
task: init agent
topic: <topic the scheduler listens to>
KPI:
  categories:
    - energy consumption: <energy>
    - compute intensity: <high,medium,low>
    - IO intensity: <high,medium,low>
    - communication intensity (network): <high,medium,low>
    - expected runtime: <high,medium,low>
    - compute device: <CPU,GPU>
    - dependencies: <next_phase>
  repeat: <number in seconds how often the KPIs are reported>
=============
  Erwartetes Verhalten: Der Agent merkt sich die entsprechende Konfiguration
                        und reagiert entsprechend. Der für den Knoten zuständige
                        Scheduler empfängt die Nachrichten über das angegebene
                        Topic.


* VMs STARTEN
  Diskussion: VM vorbereiten in Scheduler Skripten oder von Migfra?
  Source: Scheduler
  Erwartetes Verhalten: VM wird gestartet.
  Topic: <hostname>-migfra
  Payload:
=============
task: start vm
vm-configurations:
  - name: <string>
    vcpus: #CPU
    memory: #byte
  - name: <string>
    vcpus: #CPU
    memory: #byte
  - ..
=============
  Erwartetes Verhalten: Entsprechende VMs werden gestartet.


* VM GESTARTET
  Nachdem die VM gestartet ist und bereit ist eine Anwenung auszuführen wird
  folgende Nachricht verschickt.
  Source: Migfra / VM?
  Topic: <topic the scheduler listens to>
  Payload:
=============
result: vm started
list:
  - vm-name: <vm-hostname>
    status: success | error
  - vm-name: <vm-hostname>
    status: success | error
  - ..
=============
  Erwartetes Verhalten: Der für den Knoten zuständige Scheduler empfängt die
                        Nachricht und startet die Anwendung in der VM.
  Implementierung: Über mqtt_publish in Startup Skript der VM.
                   // Zwei Möglichkeiten:
                   // 1. VM sendet an migfra "vm ready", migfra sendet dies gebündelt an scheduler mit "vm started"
                   // 2. Einfacher zu implementieren, aber mehr Nachrichten an scheduler: 
                   //    Pro VM ein "vm started" ohne "vm ready" direkt von migfra oder VM an scheduler.


* VM STOPPEN
  Annahme: VM wird gestoppt wenn die Anwendung fertig ist / beendet werden soll.
  Source: Scheduler
  Topic: <hostname>-migra
  Payload:
=============
task: stop vm
list:
  - vm-name: <vm name>
  - vm-name: <vm name>
  - ..
=============
  Erwartetes Verhalten: VM wird gestoppt.


* VM GESTOPPT
  VM ist gestoppt.
  Source: Migfra
  Topic: <topic the scheduler listens to>
  Payload
=============
result: vm stopped
list:
  - vm-name: <vm-hostname>
    status: success | error
  - vm-name: <vm-hostname>
    status: success | error
  - ..
=============
  Erwartetes Verhalten: VM aufräumen? Log files für den Nutzer rauskopieren?


* ANWENDUNG STARTEN
  Anwendung soll in VM gestartet werden.
  Funktionalität bereits im Slurm Scheduler.


* NEUE ANWENDUNG AUF KNOTEN
  Anwendung wurde in einer VM gestartet oder VM wurde auf den Knoten migriert.
  Source: Scheduler / migfra
  Topic: <hostname>-A
  Payload:
=============
task: new application
job-description:
  job-id: <job id>
  process-id: <process id of the vm>
vm-configuration:
  name: <string>
  vcpus: #CPU
  memory: #byte
=============
  Erwartetes Verhalten: Agent über die VM in der die Anwendung läuft und beginnt
                        mit Optimierung.


* MONITORING / TUNING BEENDEN
  Der Agent soll aufhören die Anwendung zu überwachen.
  Source: migfra / scheduler
  Topic: <hostname>-A
  Payload
============
task: stop monitoring
job-description:
  job-id: <job id>
  process-id: <process id of the vm>
============
  Erwartetes Verhalten: Agent hört auf den Prozess zu überwachen.


* MIGRATION STARTEN
  Anwendung soll von Quell Knoten auf Ziel Knoten migriert werden.
  Source: Scheduler
  Topic: <hostname>-migfra
  Payload
============
task: migrate vm
vm-name: <vm name>
destination: <destination hostname>
parameter:
  live-migration: true | false
============


* MIGRATION FERTIG
  Meldung an den Scheduler dass die Migration fertig ist.
  Source: migfra
  Topic: <scheduler defined topic id>
  Payload
============
result: vm migrated
vm-name: <vm name>
status: success | error
============
  Erwartetes Verhalten: Scheduler markiert ursprüngliche Ressource als frei.


* ANWENDUNG <-> AGENT



-----------
Übersicht der migfra tasks:
start vm
stop vm
migrate vm

Übersicht der migfra results:
vm started
(vm ready <- von VM gesendet)
vm stopped
vm migrated

=> Eine msg pro gestartete VM oder eine msg mit allen gestarteten VMs an scheduler? (siehe Kommentar unter "vm started")
=> Einheitlicher result status: "status: success | error" (Eventuell "details: <error description>" hinzufügen für mehr Infos.)
=> Einheitlicher task/result Name: "task: <start|stop|migrate> vm", "result: vm <started|stopped|migrated>" 

Online YAML parser:
http://yaml-online-parser.appspot.com/

