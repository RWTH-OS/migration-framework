Umsetzung der Schnittstellen mit MQTT
=====================================


Annahmen
---------

* Basiert auf schnittstellen.txt von <datum>
* Scheduler kennt $ hostname aller knoten.


Aufbau einer MQTT Nachricht
---------------------------

Eine MQTT Nachricht besteht aus zwei Teilen

* Topic

* Payload in YAML


Ablauf der Kommunikation
------------------------

Grundsätzlich ist das ein einfaches Publisher-Subscriber Pattern.
Hier eine grobe Übersicht.

1. Ein Teilnehmer verbinden sich mit einem Server.

*  Ein Teilnehmer melden sich für N Topics an.

*  Der Server schickt alle Nachrichten für die sich ein Teilnehmer angemeldet
   hat.

2. Ein Teilnehmer meldet sich ab.


Topics
------

Eine Übersicht über die aktuell verwendeten Topics. Grunsätzlich ist der Aufbau
wie folgt: <Host>-<Komponente>.

* <host>-agent: Ein Topic um Nachrichten an den Agenten auf node <host> zu
                schicken.

* <host>-migfra: Ein Topic um Nachrichten an das Migrationsframework auf node <host>
                 zu schicken.

* <host>-s: Ein Topic um mit dem Scheduler zu kommunizieren der für node <host>
            zuständig ist.

* scheduler: Ein Topic das an alle Scheduler Instanzen geht.


Genaues Kommunikationsprotokoll für die verschiedenen Anwendungsfälle
---------------------------------------------------------------------

* INIT
  Knoten wird gestartet. Meldet und meldet sich beim Scheduler an.
  Source: Agent
  Topic: scheduler
  Payload:
=============
task: init
  source: <hostname>
=============
  Erwartetes Verhalten: Der für den Knoten zuständige Scheduler empfängt die
                        Nachricht und nimmt den Knoten in sein Scheduling mit
                        auf.
  Implementierung: Agent wird automatisch bei Systemstart gestartet und
                   verschickt die o.g. Nachricht.


* INIT AGENT
  Der Scheduler meldet sich beim Agenten und liefert eine initiale Konfiguration
  Source: Scheduler
  Topic: <hostname>-A
  Payload:
=============
task: init agent
  topic: <topic the scheduler listens to>
  KPI:
    categories:
      - energy consumption: <energy>
      - compute intensity: <high,medium,low>
      - IO intensity: <high,medium,low>
      - communication intensity (network): <high,medium,low>
      - expected runtime: <high,medium,low>
      - compute device: <CPU,GPU>
      - dependencies: <next_phase>
    repeat: <number in seconds how often the KPIs are reported>
=============
  Erwartetes Verhalten: Der Agent merkt sich die entsprechende Konfiguration
                        und reagiert entsprechend. Der für den Knoten zuständige
                        Scheduler empfängt die Nachrichten über das angegebene
                        Topic.


* VMs STARTEN
  Diskussion: VM vorbereiten in Scheduler Skripten oder von Migfra?
  Source: Scheduler
  Erwartetes Verhalten: VM wird gestartet.
  Topic: <hostname>-migfra
  Payload:
=============
task: start vm
  vm-configurations:
    - name: <string>
      vcpus: #CPU
      memory: #byte
    - name: <string>
      vcpus: #CPU
      memory: #byte
    - ..
=============
  Erwartetes Verhalten: Entsprechende VMs werden gestartet.


* VM GESTARTET
  Nachdem die VM gestartet ist und bereit ist eine Anwenung auszuführen wird
  folgende Nachricht verschickt.
  Source: Migfra / VM?
  Topic: <topic the scheduler listens to>
  Payload:
=============
task: vm started
  vm-name: <vm-hostname>
  status: ready | error
=============
  Erwartetes Verhalten: Der für den Knoten zuständige Scheduler empfängt die
                        Nachricht und startet die Anwendung in der VM.
  Implementierung: Über mqtt_publish in Startup Skript der VM.


* VM STOPPEN
  Annahme: VM wird gestoppt wenn die Anwendung fertig ist / beendet werden soll.
  Source: Scheduler
  Topic: <hostname>-migra
  Payload:
=============
task: vm stopped
  vm-name: <vm name>
=============
  Erwartetes Verhalten: VM wird gestoppt.


* VM GESTOPPT
  VM ist gestoppt.
  Source: Migfra
  Topic: <topic the scheduler listens to>
  Payload
=============
task: vm stopped
  vm-name: <vm-hostname>
  status: stopped | error
=============
  Erwartetes Verhalten: VM aufräumen? Log files für den Nutzer rauskopieren?


* ANWENDUNG STARTEN
  Anwendung soll in VM gestartet werden.
  Funktionalität bereits im Slurm Scheduler.


* NEUE ANWENDUNG AUF KNOTEN
  Anwendung wurde in einer VM gestartet oder VM wurde auf den Knoten migriert.
  Source: Scheduler / migfra
  Topic: <hostname>-A
  Payload:
=============
task: new application
  job-description:
    job-id: <job id>
    process-id: <process id of the vm>
  vm-configuration:
    name: <string>
    vcpus: #CPU
    memory: #byte
=============
  Erwartetes Verhalten: Agent über die VM in der die Anwendung läuft und beginnt
                        mit Optimierung.


* MONITORING / TUNING BEENDEN
  Der Agent soll aufhören die Anwendung zu überwachen.
  Source: migfra / scheduler
  Topic: <hostname>-A
  Payload
============
task: stop monitoring
  job-description:
    job-id: <job id>
    process-id: <process id of the vm>
============
  Erwartetes Verhalten: Agent hört auf den Prozess zu überwachen.


* MIGRATION STARTEN
  Anwendung soll von Quell Knoten auf Ziel Knoten migriert werden.
  Source: Scheduler
  Topic: <hostname>-migfra
  Payload
============
task: migrate start
  vm-name: <vm name>
  destination: <destination hostname>
  parameter:
    live migration: true | false
============


* MIGRATION FERTIG
  Meldung an den Scheduler dass die Migration fertig ist.
  Source: migfra
  Topic: <scheduler defined topic id>
  Payload
============
task: migrate done
  vm-name: <vm name>
============
  Erwartetes Verhalten: Scheduler markiert ursprüngliche Ressource als frei.


* ANWENDUNG <-> AGENT
